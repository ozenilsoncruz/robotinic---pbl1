// Definicao dos motores ativos
#define MOTOR_GARRA OUT_B
#define MOTOR_DIREITO OUT_A
#define MOTOR_ESQUERDO OUT_C
#define MOTOR_DIREITO_ESQUERDO OUT_AC

// Definicao dos sensores ativos
#define SENSOR_COR S3
#define SENSOR_TOQUE S1
#define SENSOR_ULTRASSOM S2

// Canal de comunica??o Bluetooth
#define MAILBOX_RECIVE 1
#define MAILBOX_SEND 2

// Potencias dos motores
#define VELOCIDADE_MAXIMA 100
#define VELOCIDADE_MEDIA 40
#define VELOCIDADE_MINIMA 30

// Distancia maxima permitida da parede
#define DISTANCIA_PAREDE 22
#define DISTANCIA_OBJETO 25

// Cores usadas
#define PRETO 1
#define PRATA 2
#define BRANCO 3
#define VERMELHO 4


// Medidas do rob?
#define DIAMETRO_RODA 7
#define DISTANCIA_ENTRE_RODAS 20


enum Estado {
    SAIR_BASE,
    MOVER_PARA_ESTOQUE,
    PROCURAR_OBJETO,
    SAIR_ESTOQUE,
    ENTRAR_ESTACAO_TRABALHO,
    ESTACAO_TRABALHO,
    SAIR_ESTACAO_TRABALHO,
    RETORNAR_BASE
};

Estado estadoAtual;

// Vari?veis globais
float x = 0;
float y = 0;
float angulo = 0;

int corDetectada = 0;
bool girar_Direita = true;
bool procurarObjeto = false;
bool objetoAdquirido = false;

float motorEsquerdoCount = 0;
float motorDireitoCount = 0;


mutex motorDireitoEsquerdoMutex;

void enviarMensagem(string msg) {
    SendMessage(MAILBOX_SEND, msg);
}

void calcularOdometria() {
    motorDireitoCount = MotorRotationCount(MOTOR_DIREITO)/360;
    motorEsquerdoCount = MotorRotationCount(MOTOR_ESQUERDO)/360;
    float deslocamento_motor_direito = motorDireitoCount * PI * (DIAMETRO_RODA);
    float deslocamento_motor_esquerdo = motorEsquerdoCount * PI * (DIAMETRO_RODA);
    float compensacao_motor_direito = 1.5 * motorDireitoCount * PI;
    float compensacao_motor_esquerdo = 1.5 * motorEsquerdoCount * PI;
    float deslocamento_medio = ((deslocamento_motor_direito - compensacao_motor_direito) + (deslocamento_motor_esquerdo) - compensacao_motor_esquerdo) / 2;
    float mudanca_angulo = (deslocamento_motor_direito - deslocamento_motor_esquerdo) / (DISTANCIA_ENTRE_RODAS);

    angulo += mudanca_angulo;

    float delta_x = deslocamento_medio * Cos(angulo);
    float delta_y = deslocamento_medio * Sin(angulo);

    x += delta_x;
    y += delta_y;

    string msg = "{x: " + NumToStr(x) + ", y: " + NumToStr(y) + "}";
    enviarMensagem(msg);
    ResetRotationCount(MOTOR_DIREITO);
    ResetRotationCount(MOTOR_ESQUERDO);
}


void acionarMotor(int motor, float num_voltas, bool frente=true) {

    int graus_motor = 360 * num_voltas;  // Quantos graus o motor deve girar

    if (frente) {
        RotateMotorEx(motor, VELOCIDADE_MEDIA, graus_motor, 0, true, false);
    }
    else {
        RotateMotorEx(motor, -VELOCIDADE_MEDIA, graus_motor, 0, true, false);

    }
    calcularOdometria();

}


void acionarMotores(bool frente=true) {
    if(frente) {
        // TODO: testar se o rob? caminha reto
        OnFwdSync(MOTOR_DIREITO_ESQUERDO, VELOCIDADE_MEDIA, 0);
    }
    else {
        OnRevSync(MOTOR_DIREITO_ESQUERDO, VELOCIDADE_MEDIA, 0);
    }
}



void girarEmGraus(int graus) {
    float distancia_entre_rodas = DISTANCIA_ENTRE_RODAS;
    float raio_roda = (DIAMETRO_RODA )/ 2.0;

    // Dist?ncia que a roda externa precisa percorrer
    float distancia_percorrida = (distancia_entre_rodas * PI * abs(graus)) / 360.0;

    // N?mero de rota??es que cada roda deve fazer
    float numero_rotacoes = distancia_percorrida / (2 * PI * raio_roda);

    // Quantos graus os motores devem girar
    int graus_motor = 360 * numero_rotacoes;

    // Se o grau ? positivo, girar para a direita. Se negativo, girar para a esquerda.
    if (graus > 0) {
        // Girar para a direita
        RotateMotorEx(MOTOR_DIREITO_ESQUERDO, VELOCIDADE_MEDIA, graus_motor, -100, true, true);
    } else {
        // Girar para a esquerda
        RotateMotorEx(MOTOR_DIREITO_ESQUERDO, VELOCIDADE_MEDIA, graus_motor, 100, true, true);
    }
    calcularOdometria();
}


void andarFrente() {
    acionarMotores();
}

void andarFrenteUmaVez() {
    acionarMotor(MOTOR_DIREITO_ESQUERDO, 1);
}

void andarFrenteNumeroVezes(float vezes) {
    acionarMotor(MOTOR_DIREITO_ESQUERDO, vezes);
}

void andarTras() {
    acionarMotores(false);
}

void andarTrasUmaVez() {
    acionarMotor(MOTOR_DIREITO_ESQUERDO, 0.5, false);
}

void andarTrasNumeroVezes(float vezes) {
    acionarMotor(MOTOR_DIREITO_ESQUERDO, vezes, false);
}

void frear() {
    Off(MOTOR_DIREITO_ESQUERDO);
    calcularOdometria();
}

void girarDireita() {
    girarEmGraus(-90);
}

void girarEsquerda() {
    girarEmGraus(90);
}

void girar180() {
    girarEmGraus(180);
}

void acionarGarra() {
    OnRev(MOTOR_GARRA, VELOCIDADE_MINIMA);
    Wait(1000);
    Off(MOTOR_GARRA);
}

void liberarGarra() {
    RotateMotor(MOTOR_GARRA, VELOCIDADE_MINIMA, 75);
}


bool pegarObjeto() {
    int valor = SensorUS(SENSOR_ULTRASSOM);
    if (SensorUS(SENSOR_ULTRASSOM) < DISTANCIA_OBJETO && Sensor(SENSOR_TOQUE) == 0) {
        frear();
        andarFrenteNumeroVezes(1);
        acionarGarra();
        objetoAdquirido = true;
        return true;
    }
    return false;
}

string lerCor(int cor) {
    if (cor == 1) {
        return "Preto";
    }
    else if (cor == 2) {
        return "Prata";
    }
    else if (cor == 3) {
        return "Branco";
    }
    else return "Nao identificado";
}

task mostrarInformacoes() {
    while(true) {
        ClearScreen();
        int distancia = SensorUS(SENSOR_ULTRASSOM);
        int valorLuz = Sensor(SENSOR_COR);
        TextOut(0, LCD_LINE1, "Dis:" + NumToStr(distancia) + "Obj:" + NumToStr(objetoAdquirido));
        TextOut(0, LCD_LINE2, "Cor:" + lerCor(corDetectada) + " V:" + NumToStr(valorLuz));
        TextOut(0, LCD_LINE3, "Estado:" + NumToStr(estadoAtual));
        TextOut(0, LCD_LINE4, "D:" + NumToStr(motorDireitoCount) + " E:" + NumToStr(motorEsquerdoCount));
        TextOut(0, LCD_LINE5, "X:" + NumToStr(x/100));
        TextOut(0, LCD_LINE6, "Y:" + NumToStr(y/100));
        TextOut(0, LCD_LINE7, "Angulo: " + NumToStr(angulo * 57.2958));
        TextOut(0, LCD_LINE8, "Garra: " + NumToStr(MotorRotationCount(MOTOR_GARRA)));
        Wait(100);
    }
}


task detectarParede() {
    while (true) {
        Acquire(motorDireitoEsquerdoMutex);
        if (Sensor(SENSOR_TOQUE) == 1) {
            frear();
            andarTrasUmaVez();
            girarDireita();
        }
        Release(motorDireitoEsquerdoMutex);
    }
}


task explorar() {
    while (true) {
        Acquire(motorDireitoEsquerdoMutex);
        if(procurarObjeto && !objetoAdquirido) {
            andarFrenteUmaVez();
            if(pegarObjeto()) continue;
            girarEmGraus(-45);
            if(pegarObjeto()) continue;
            girarEmGraus(90);
            if(pegarObjeto()) continue;
            girarEmGraus(-45);
        }
        Release(motorDireitoEsquerdoMutex);
    }
}

task detectarObjeto() {
    while (true) {
        if(procurarObjeto) {
            Acquire(motorDireitoEsquerdoMutex);
            int valor = SensorUS(SENSOR_ULTRASSOM);
            if (SensorUS(SENSOR_ULTRASSOM) < DISTANCIA_OBJETO && Sensor(SENSOR_TOQUE) == 0) {
                frear();
                andarFrenteNumeroVezes(0.8);
                acionarGarra();
                objetoAdquirido = true;
            }
            Release(motorDireitoEsquerdoMutex);
        }
    }
}


task detectarCor() {
    // TODO: Implementar l?gica para detectar a cor vermelha
    // SetSensorLight(SENSOR_COR, false);
    while (true) {
        int valorLuz = Sensor(SENSOR_COR);
        if (valorLuz < 40) {
            corDetectada = PRETO;
        }
        else if (valorLuz >= 40 && valorLuz < 60) {
            corDetectada = BRANCO;
        }
        else if (valorLuz >= 65) {
            corDetectada = PRATA;
        }
        Wait(100);
    }
}


// Fun??o principal de atualiza??o de estado
task atualizarEstado() {
    estadoAtual = PROCURAR_OBJETO;
    while (true) {
        Acquire(motorDireitoEsquerdoMutex);
        switch (estadoAtual) {
            // case SAIR_BASE: //Estado OK!
            //     if (corDetectada == PRATA) {
            //         frear();
            //         andarFrente();
            //         Wait(1000);
            //         estadoAtual = MOVER_PARA_ESTOQUE;
            //     }
            //     else if(corDetectada == BRANCO) {
            //         andarFrente();
            //     }
            //     else if (corDetectada == PRETO) {
            //         frear();
            //         andarTrasUmaVez();
            //         girarDireita();
            //         andarFrenteUmaVez();
            //         girarEsquerda();
            //     }
            //     break;
            // case MOVER_PARA_ESTOQUE:
            //     if (corDetectada == PRATA) {
            //         frear();
            //         andarFrenteUmaVez();
            //         girarEsquerda();
            //         // estadoAtual = PROCURAR_OBJETO;
            //     }
            //     else if(corDetectada == BRANCO) {
            //         andarFrente();
            //     }
            //     else if (corDetectada == PRETO) {
            //         frear();
            //         andarTrasUmaVez();
            //         girarDireita();
            //         andarFrenteUmaVez();
            //         girarEsquerda();
            //     }
            //     break;
            case PROCURAR_OBJETO:
                procurarObjeto = true;
                if (objetoAdquirido) {
                    procurarObjeto = false;
                    andarFrente();
                    // estadoAtual = SAIR_ESTOQUE;
                    break;
                }
                else if(corDetectada == PRATA || corDetectada == PRETO) {
                    frear();
                    andarTrasUmaVez();
                    girarDireita();
                }
                else if(corDetectada == BRANCO) {
                    andarFrente();
                }
                break;
            // case SAIR_ESTOQUE:
            //     if (corDetectada == PRATA) {
            //         frear();
            //         andarFrenteUmaVez();
            //         girarEsquerda();
            //         estadoAtual = ENTRAR_ESTACAO_TRABALHO,;
            //         andarFrente();
            //     }
            //     else if(corDetectada == BRANCO) {
            //         andarFrente();
            //     }
            //     else if (corDetectada == PRETO) {
            //         frear();
            //         andarTrasUmaVez();
            //         girarDireita();
            //         andarFrenteUmaVez();
            //         girarEsquerda();
            //     }
            //     break;

        //     case ENTRAR_ESTACAO_TRABALHO:
        //         if (corDetectada == PRATA) {
        //             andarFrente();
        //             estadoAtual = ESTACAO_TRABALHO;
        //             break;
        //         }
        //         if(corDetectada == BRANCO) {
        //             andarFrente();
        //         }
        //         else if (corDetectada == PRETO) {
        //             frear();
        //             andarTrasUmaVez();
        //             girarDireita();
        //             andarFrenteUmaVez();
        //             girarEsquerda();
        //             andarFrenteUmaVez();
        //             girarEsquerda();
        //         }
        //         break;
            // case: ESTACAO_TRABALHO:
            //     SetSensorLight(SENSOR_COR, false);
            //     if (corDetectada == VERMELHO) {
            //         frear();
            //         girar180();
            //         andarFrente();
            //         estadoAtual = SAIR_ESTACAO_TRABALHO;
            //         SetSensorLight(SENSOR_COR, true);
            //         break;
            //     }
            //     if(corDetectada == BRANCO) {
            //         andarFrente();
            //     }
            //     else if (corDetectada == PRETO) {
            //         frear();
            //         andarTrasUmaVez();
            //         liberarGarra();
            //         girar180();
            //         andarFrente();
            //         estadoAtual = SAIR_ESTACAO_TRABALHO;
            //         SetSensorLight(SENSOR_COR, true);
            //     }
            //     break;
        //     case SAIR_ESTACAO_TRABALHO:
        //         if (corDetectada == PRATA) {
        //             if(objetoAdquirido) {
        //                 frear();
        //                 andarFrenteUmaVez();
        //                 girarEsquerda();
        //                 estadoAtual = RETORNAR_BASE;
        //                 andarFrente();
        //             }
        //             else {
        //                 andarFrente();
        //                 estadoAtual = ENTRAR_ESTACAO_TRABALHO;
        //             }
        //         }
        //         else if(corDetectada == BRANCO) {
        //             andarFrente();
        //         }
        //         else if (corDetectada == PRETO) {
        //             frear();
        //             andarTrasUmaVez();
        //             girarDireita();
        //         }
        //         break;
        }
        Release(motorDireitoEsquerdoMutex);
        Wait(100);
    }
}

task main() {
    SetSensorLight(SENSOR_COR);
    SetSensorTouch(SENSOR_TOQUE);
    SetSensorUltrasonic(SENSOR_ULTRASSOM);

    // SendMessage(MAILBOX_SEND, "Iniciando rob?");

    // string msg = "";
    // while(msg == "") {
    //     ReceiveMessage(MAILBOX_RECIVE, true, msg);
    // }

    //andarFrenteNumeroVezes(0.5);
    //Precedes(mostrarInformacoes);
    Precedes(atualizarEstado, mostrarInformacoes, detectarCor, detectarParede, explorar);



}






















