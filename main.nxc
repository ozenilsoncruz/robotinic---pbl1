// Definicao dos motores ativos
#define MOTOR_GARRA OUT_B
#define MOTOR_DIREITO OUT_A
#define MOTOR_ESQUERDO OUT_C
#define MOTOR_DIREITO_ESQUERDO OUT_AC

// Definicao dos sensores ativos
#define SENSOR_COR S3
#define SENSOR_TOQUE S1
#define SENSOR_ULTRASSOM S2

// Canal de comunicação Bluetooth
#define CANAL 1 

// Potencias dos motores
#define VELOCIDADE_MAXIMA 100
#define VELOCIDADE_MEDIA 50
#define VELOCIDADE_MINIMA 30

// Distancia maxima permitida da parede
#define DISTANCIA 30

// Cores usadas
#define PRETO 1
#define PRATA 2
#define BRANCO 3
#define VERMELHO 4


// Medidas do robô
#define DIAMETRO_RODA 7
#define DISTANCIA_ENTRE_RODAS 20


// Variáveis globais
float x = 0;
float y = 0;
float angulo = 0;


int lerCor() {
    int valorLuz = Sensor(SENSOR_COR);

    if (valorLuz < 40) {
        return PRETO;
    }
    else if(valorLuz > 50 && valorLuz < 56){
         return VERMELHO;
    }
    else if (valorLuz >= 40 && valorLuz < 60) {
        return BRANCO;
    }
    else if (valorLuz >= 60) {
        return PRATA;
    }

    return -1;
}


// Aciona o motor para girar um determinado número de voltas
// void acionarMotor(int motor, float num_voltas, bool frente=true) {
//     Off(motor);
//     ResetRotationCount(motor); 
    
//     if (frente) {
//         OnFwd(motor, VELOCIDADE_MEDIA);
//     } else {
//         OnRev(motor, VELOCIDADE_MEDIA);
//     }

//     int graus_motor = 360 * num_voltas;  // Quantos graus o motor deve girar
    
//     do {
//         int rotacaoMotor = MotorRotationCount(motor);
//         ClearScreen();
//         TextOut(0, 56, NumToStr(rotacaoMotor));
//         Wait(100);  
//     } while (abs(MotorRotationCount(motor)) < abs(graus_motor));
    
//     Off(motor);
// }


void acionarMotor(int motor, float num_voltas, bool frente=true) {
    Off(motor);
    ResetRotationCount(motor); 
    
    int graus_motor = 360 * num_voltas;  // Quantos graus o motor deve girar

    if (frente) {
        RotateMotor(motor, VELOCIDADE_MEDIA, graus_motor);
    } 
    else {
        RotateMotor(motor, -VELOCIDADE_MEDIA, graus_motor);
    }

}



// Aciona ambos os motores definidos para girar um determinado número de voltas
// void acionarMotores(float num_voltas, bool frente=true) {
//     Off(MOTOR_DIREITO_ESQUERDO);
//     ResetRotationCount(MOTOR_DIREITO_ESQUERDO); 

//     if (frente) {
//         OnFwd(MOTOR_DIREITO_ESQUERDO, VELOCIDADE_MEDIA);
//     }
//     else {
//         OnRev(MOTOR_DIREITO_ESQUERDO, VELOCIDADE_MEDIA);
//     }

//     int graus = 360 * num_voltas;
//     bool continuar;
//     do {
//         int rotacaoMotor = MotorRotationCount(MOTOR_ESQUERDO);
//         ClearScreen();
//         TextOut(0, 56, NumToStr(rotacaoMotor));
//         Wait(100);
//         continuar = frente ? rotacaoMotor < graus : rotacaoMotor > graus;
//     } while (continuar);
//     Off(MOTOR_DIREITO_ESQUERDO);
// }


void acionarMotores(bool frente=true) {
    if(frente) {
        OnFwd(MOTOR_DIREITO_ESQUERDO, VELOCIDADE_MEDIA);
    }
    else {
        acionarMotor(MOTOR_DIREITO_ESQUERDO, 0.5, false);
    }
}




// Gira o robô em um determinado número de graus
void girarEmGraus(int graus) {
    float distancia_entre_rodas = DISTANCIA_ENTRE_RODAS;  
    float raio_roda = DIAMETRO_RODA / 2.0;  
    
    // Distância que a roda externa precisa percorrer
    float distancia_percorrida = (distancia_entre_rodas * PI * abs(graus)) / 360.0;
    
    // Número de rotações que cada roda deve fazer
    float numero_rotacoes = distancia_percorrida / (2 * PI * raio_roda);

    if (graus > 0) {
        // Girar para a direita
        acionarMotor(OUT_C, numero_rotacoes, true);  // Esquerda para frente
        acionarMotor(OUT_A, numero_rotacoes, false); // Direita para trás
        //RotateMotorEx(MOTOR_DIREITO_ESQUERDO, VELOCIDADE_MEDIA, 300, 100, true, true);
    } else {
        // Girar para a esquerda
        acionarMotor(OUT_C, numero_rotacoes, false); // Esquerda para trás
        acionarMotor(OUT_A, numero_rotacoes, true);  // Direita para frente
        //RotateMotorEx(MOTOR_DIREITO_ESQUERDO, VELOCIDADE_MEDIA, 300, -100, true, true);
    }
}


void calcularOdometria(){
    float deslocamento_motor_direito = MotorRotationCount(MOTOR_DIREITO) * PI * DIAMETRO_RODA;
    float deslocamento_motor_esquerdo = MotorRotationCount(MOTOR_ESQUERDO) * PI * DIAMETRO_RODA;
    float deslocamento_medio = (deslocamento_motor_direito + deslocamento_motor_esquerdo) / 2;
    float mudanca_angulo = (deslocamento_motor_direito - deslocamento_motor_esquerdo) / DISTANCIA_ENTRE_RODAS;

    angulo += mudanca_angulo;

    // Para projetos de robótica, é comum modificar esse ângulo para que ele esteja sempre entre -pi e +pi.
    if (angulo > PI) {
        angulo -= 2 * PI;
    } else if (angulo < -PI) {
        angulo += 2 * PI;
    }

    float delta_x = deslocamento_medio * Cos(angulo);
    float delta_y = deslocamento_medio * Sin(angulo);

    x += delta_x;
    y += delta_y;

    ClearScreen();
    TextOut(0, 56, "X: " + NumToStr(x));
    TextOut(0, 72, "Y: " + NumToStr(y));
    TextOut(0, 88, "Angulo: " + NumToStr(angulo));
}


void andarFrente() {
    acionarMotores();
    calcularOdometria();
}

void andarFrenteUmaVez() {
    acionarMotor(MOTOR_DIREITO_ESQUERDO, 1);
    calcularOdometria();
}

void andarTras() {
    acionarMotores(false);
    calcularOdometria();
}

void girarDireita() {
    girarEmGraus(90);
    calcularOdometria();
}

void girarEsquerda() {
    girarEmGraus(-90);
    calcularOdometria();
}


// Rotina para teste
void rotinaPrincipal() {
    while (true) {
        int cor = lerCor();
         if (cor == PRETO) {
            andarTras();
            girarEsquerda();
            andarFrenteUmaVez();
            girarDireita();
        } else if (cor == PRATA) {
            // TODO: Atualizar estado do robô
            ClearScreen();
            TextOut(0, 56, "Chegou no prata!");
            Wait(5000);
            break;
        }
        else {
             andarFrente();
             }
    }
}


task main() {
    SetSensorLight(SENSOR_COR);
    SetSensorTouch(SENSOR_TOQUE);
    SetSensorUltrasonic(SENSOR_ULTRASSOM);

    ClearScreen();
    TextOut(0, 56, "Clique");
    while(Sensor(SENSOR_TOQUE) == 0) {};
    
    ClearScreen();
    TextOut(0, 56, "Bluetooth");
    while (BluetoothStatus(CANAL) == NO_ERR) {
        Wait(100);
    }

    string msg;

    while (true){
        if (ReceiveRemoteString(CANAL, true, msg) == NO_ERR){
            ClearScreen();
            TextOut(0, 56, msg);
            Wait(10000);
            BluetoothWrite(CANAL, "sair");
            // SendRemoteString(CANAL, 1, "sair"); // testar com esse
            break;
        }
    }

    //andarFrente();
    //andarTras();
    //girarDireita();
    //girarEsquerda();

    rotinaPrincipal();
}
