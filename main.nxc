// Definicao dos motores ativos
#define MOTOR_GARRA OUT_B
#define MOTOR_DIREITO OUT_A
#define MOTOR_ESQUERDO OUT_C
#define MOTOR_DIREITO_ESQUERDO OUT_AC

// Definicao dos sensores ativos
#define SENSOR_COR S3
#define SENSOR_TOQUE S1
#define SENSOR_ULTRASSOM S2

// Canal de comunica??o Bluetooth
#define MAILBOX_RECIVE 1
#define MAILBOX_SEND 2

// Potencias dos motores
#define VELOCIDADE_MAXIMA 100
#define VELOCIDADE_MEDIA 50
#define VELOCIDADE_MINIMA 30

// Distancia maxima permitida da parede
#define DISTANCIA_PAREDE 20
#define DISTANCIA_OBJETO 5

// Cores usadas
#define PRETO 1
#define PRATA 2
#define BRANCO 3
#define VERMELHO 4


// Medidas do rob?
#define DIAMETRO_RODA 7
#define DISTANCIA_ENTRE_RODAS 20


enum Estado {
    SAIDA_BASE,
    MOVER_PARA_ESTOQUE,
    PROCURAR_OBJETO,
    SAIR_ESTOQUE,
    MOVER_PARA_ESTACAO_TRABALHO,
    SOLTAR_OBJETO,
    RETORNAR_BASE
};

Estado estadoAtual;

// Vari?veis globais
float x = 0;
float y = 0;
float angulo = 0;

int corDetectada = 0;
bool girar_Direita = true;
bool explorar = false;
bool objetoDetectado = false;


mutex objetoDetectadoMutex;
mutex explorarMutex;



void acionarMotor(int motor, float num_voltas, bool frente=true) {
    Off(motor);
    ResetRotationCount(motor);

    int graus_motor = 360 * num_voltas;  // Quantos graus o motor deve girar

    if (frente) {
        RotateMotor(motor, VELOCIDADE_MEDIA, graus_motor);
    }
    else {
        RotateMotor(motor, -VELOCIDADE_MEDIA, graus_motor);

    }

}


void acionarMotores(bool frente=true) {
    if(frente) {
        OnFwd(MOTOR_DIREITO_ESQUERDO, VELOCIDADE_MEDIA);
    }
    else {
        OnRev(MOTOR_DIREITO_ESQUERDO, VELOCIDADE_MEDIA);
    }
}



void girarEmGraus(int graus) {
    float distancia_entre_rodas = DISTANCIA_ENTRE_RODAS;
    float raio_roda = DIAMETRO_RODA / 2.0;

    // Dist?ncia que a roda externa precisa percorrer
    float distancia_percorrida = (distancia_entre_rodas * PI * abs(graus)) / 360.0;

    // N?mero de rota??es que cada roda deve fazer
    float numero_rotacoes = distancia_percorrida / (2 * PI * raio_roda);

    // Quantos graus os motores devem girar
    int graus_motor = 360 * numero_rotacoes;

    // Se o grau ? positivo, girar para a direita. Se negativo, girar para a esquerda.
    if (graus > 0) {
        // Girar para a direita
        RotateMotorEx(MOTOR_DIREITO_ESQUERDO, VELOCIDADE_MEDIA, graus_motor, -100, true, true);
    } else {
        // Girar para a esquerda
        RotateMotorEx(MOTOR_DIREITO_ESQUERDO, VELOCIDADE_MEDIA, graus_motor, 100, true, true);
    }
}


void calcularOdometria() {
    float deslocamento_motor_direito = MotorRotationCount(MOTOR_DIREITO) * PI * DIAMETRO_RODA;
    float deslocamento_motor_esquerdo = MotorRotationCount(MOTOR_ESQUERDO) * PI * DIAMETRO_RODA;
    float deslocamento_medio = (deslocamento_motor_direito + deslocamento_motor_esquerdo) / 2;
    float mudanca_angulo = (deslocamento_motor_direito - deslocamento_motor_esquerdo) / DISTANCIA_ENTRE_RODAS;

    angulo += mudanca_angulo;

    // Para projetos de rob?tica, ? comum modificar esse ?ngulo para que ele esteja sempre entre -pi e +pi.
    if (angulo > PI) {
        angulo -= 2 * PI;
    } else if (angulo < -PI) {
        angulo += 2 * PI;
    }

    float delta_x = deslocamento_medio * Cos(angulo);
    float delta_y = deslocamento_medio * Sin(angulo);

    x += delta_x;
    y += delta_y;

    ClearScreen();
    TextOut(0, LCD_LINE1, "X: " + NumToStr(x));
    TextOut(0, LCD_LINE2, "Y: " + NumToStr(y));
    TextOut(0, LCD_LINE3, "Angulo: " + NumToStr(angulo));
}


void andarFrente() {
    acionarMotores();
}

void andarFrenteUmaVez() {
    acionarMotor(MOTOR_DIREITO_ESQUERDO, 1);
}

void andarFrenteNumeroVezes(int vezes) {
    acionarMotor(MOTOR_DIREITO_ESQUERDO, vezes);
}

void andarTras() {
    acionarMotores(false);
}

void andarTrasUmaVez() {
    acionarMotor(MOTOR_DIREITO_ESQUERDO, 1, false);
}

void frear() {
    Off(MOTOR_DIREITO_ESQUERDO);
}

void girarDireita() {
    girarEmGraus(90);
}

void girarEsquerda() {
    girarEmGraus(-90);
}

void girar180() {
    girarEmGraus(180);
}

void acionarGarra() {
    acionarMotor(MOTOR_GARRA, 0.25, false);
    ClearScreen();
    TextOut(0, LCD_LINE1, "Acionar garra");
}

void liberarGarra() {
    acionarMotor(MOTOR_GARRA, 0.25);
    Off(MOTOR_GARRA);
    ClearScreen();
    TextOut(0, LCD_LINE1, "Liberou a garra");
}


task seguirLinhaPreta() {
    bool ajustarParaDireita = true;  
    while (true) {
        
        if (corDetectada == PRETO) {  
            andarFrente();  
        }
        // Se o sensor detecta outra cor (linha perdida)
        else {
            frear();  
            if (ajustarParaDireita) {
                // Curva ligeira para a direita
                OnFwd(MOTOR_DIREITO, VELOCIDADE_MINIMA);
                OnRev(MOTOR_ESQUERDO, VELOCIDADE_MINIMA);
                Wait(200);  
            } else {
                // Curva ligeira para a esquerda
                OnFwd(MOTOR_ESQUERDO, VELOCIDADE_MINIMA);
                OnRev(MOTOR_DIREITO, VELOCIDADE_MINIMA);
                Wait(200);  
            }
            ajustarParaDireita = !ajustarParaDireita;
        }
        Wait(50);  // Pequeno intervalo para evitar leituras excessivamente rÃ¡pidas
    }
}



task detectarObstaculo() {
    while (true) {
        int valor = SensorUS(SENSOR_ULTRASSOM);
        if(valor < DISTANCIA_PAREDE){
            Acquire(explorarMutex);
            explorar = false;
            andarFrenteNumeroVezes(0.5);
            valor = SensorUS(SENSOR_ULTRASSOM);
            if (Sensor(SENSOR_TOQUE) == 1) { //Parede
                ClearScreen();
                TextOut(0, LCD_LINE1, "Parede detectada!");
                explorar = false;
                if (girar_Direita) {
                    girarDireita();
                }
                else {
                    girarEsquerda();
                }
                andarFrenteNumeroVezes(0.5);
                if (girar_Direita) {
                    girarDireita();
                }
                else {
                    girarEsquerda();
                }
                girar_Direita = !girar_Direita;
                explorar = true;
            }
            else if (valor < DISTANCIA_OBJETO && objetoDetectado == false) {
                ClearScreen();
                TextOut(0, LCD_LINE1, "Objeto detectado!");
                objetoDetectado = true;
                andarFrenteUmaVez();
                acionarGarra();
            }
            Release(explorarMutex);
        }

    }
}

task detectarCor() {
    while (true) {
        int valorLuz = Sensor(SENSOR_COR);
        if (valorLuz < 40) {
            corDetectada = PRETO;
        }
        else if(valorLuz >= 50 && valorLuz < 56){
            corDetectada = VERMELHO;
        }
        else if (valorLuz >= 40 && valorLuz < 50) {
            corDetectada = BRANCO;
        }
        else if (valorLuz >= 60) {
            corDetectada = PRATA;
        }
        ClearScreen();

        if (corDetectada == PRETO) {
            TextOut(0, LCD_LINE1, "Preto detectado");
        }
        else if (corDetectada == VERMELHO) {
            TextOut(0, LCD_LINE1, "Vermelho detectado");
        }
        else if (corDetectada == BRANCO) {
            TextOut(0, LCD_LINE1, "Branco detectado");
        }
        else if (corDetectada == PRATA) {
            TextOut(0, LCD_LINE1, "Prata detectado");
        }
        Wait(200);
    }
}


// Explorar o ambiente em busca do objeto,
task explorarAmbiente() {
    exploracao:
        while (explorar) {
            andarFrente();
            int valor = SensorUS(SENSOR_ULTRASSOM);
            if(valor < DISTANCIA_PAREDE){
                Acquire(explorarMutex);
                frear();
                andarFrenteNumeroVezes(0.5);
                valor = SensorUS(SENSOR_ULTRASSOM);
                if (Sensor(SENSOR_TOQUE) == 1) { //Parede
                    ClearScreen();
                    TextOut(0, LCD_LINE1, "Parede detectada!");
        
                    if (girar_Direita) {
                        girarDireita();
                    }
                    else {
                        girarEsquerda();
                    }
                    andarFrenteNumeroVezes(0.5);
                    if (girar_Direita) {
                        girarDireita();
                    }
                    else {
                        girarEsquerda();
                    }
                    girar_Direita = !girar_Direita;
                    andarFrente();
                }
                else if (valor < DISTANCIA_OBJETO && objetoDetectado == false) {
                    ClearScreen();
                    TextOut(0, LCD_LINE1, "Objeto detectado!");
                    objetoDetectado = true;
                    andarFrenteUmaVez();
                    acionarGarra();
                }
                Release(explorarMutex);
            }
        }
    while (!explorar) {
        frear();
        ClearScreen();
        TextOut(0, LCD_LINE1, "Parado!");
        Wait(100);
    }
    goto exploracao;

}


// Fun??o principal de atualiza??o de estado
task atualizarEstado() {
    estadoAtual = SAIDA_BASE;
    while (true) {
        Acquire(explorarMutex);
        switch (estadoAtual) {
            case SAIDA_BASE:
                andarFrente();
                if (corDetectada == PRATA) {
                    estadoAtual = MOVER_PARA_ESTOQUE;
                }
                else if (corDetectada == PRETO) {
                    frear();
                    andarTrasUmaVez();
                }	
                ClearScreen();
                TextOut(0, LCD_LINE1, "Saindo da base");
                break;
            // NOTE: Pode ser que ele detecte a cor prata novamente, come?ando a procurar o objeto antes de chegar no estoque
            case MOVER_PARA_ESTOQUE:
                andarFrente();
                if (corDetectada == PRATA) {
                    frear();
                    andarFrenteUmaVez();
                    girarEsquerda();
                    estadoAtual = PROCURAR_OBJETO;
                }
                else if (corDetectada == PRETO) {
                    frear();
                    andarTrasUmaVez();
                    girarDireita();
                    andarFrenteUmaVez();
                    girarEsquerda();
                }
                ClearScreen();
                TextOut(0, LCD_LINE1, "Entrando no estoque");
                break;

            case PROCURAR_OBJETO:
                explorar = true;
                if (objetoDetectado) {
                    estadoAtual = SAIR_ESTOQUE;
                }
                ClearScreen();
                TextOut(0, LCD_LINE1, "Objeto detectado");
                break;
            case SAIR_ESTOQUE: //TODO: implementar a partir daqui
                if (corDetectada == PRATA) {
                    girar180();
                    Wait(5000);
                }
                else if (corDetectada == PRETO) {
                    frear();
                    andarTrasUmaVez();
                    girarDireita();
                    andarFrenteUmaVez();
                    girarEsquerda();
                }
                break;
        }
        Release(explorarMutex);
    }
}

task main() {
    SetSensorLight(SENSOR_COR);
    SetSensorTouch(SENSOR_TOQUE);
    SetSensorUltrasonic(SENSOR_ULTRASSOM);

    ClearScreen();
    TextOut(0, LCD_LINE1, "Clique");
    while(Sensor(SENSOR_TOQUE) == 0) {};
    Wait(1000);

    Precedes(atualizarEstado, explorarAmbiente, detectarCor);
}



