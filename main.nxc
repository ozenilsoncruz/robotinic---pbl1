// Definicao dos motores ativos
#define MOTOR_GARRA OUT_B
#define MOTOR_DIREITO OUT_A
#define MOTOR_ESQUERDO OUT_C
#define MOTOR_DIREITO_ESQUERDO OUT_AC

// Definicao dos sensores ativos
#define SENSOR_COR S3
#define SENSOR_TOQUE S1
#define SENSOR_ULTRASSOM S2

// Canal de comunicação Bluetooth
#define CANAL 1 

// Potencias dos motores
#define VELOCIDADE_MAXIMA 100
#define VELOCIDADE_MEDIA 50
#define VELOCIDADE_MINIMA 30

// Distancia maxima permitida da parede
#define DISTANCIA 30

// Cores usadas
#define PRETO 1
#define PRATA 2
#define BRANCO 3
#define VERMELHO 4


// Medidas do robô
#define DIAMETRO_RODA 7
#define DISTANCIA_ENTRE_RODAS 20


// Variáveis globais
float x = 0;
float y = 0;
float angulo = 0;

int corGlobal = 0;


void acionarMotor(int motor, float num_voltas, bool frente=true) {
    Off(motor);
    ResetRotationCount(motor); 
    
    int graus_motor = 360 * num_voltas;  // Quantos graus o motor deve girar

    if (frente) {
        RotateMotor(motor, VELOCIDADE_MEDIA, graus_motor);
    } 
    else {
        RotateMotor(motor, -VELOCIDADE_MEDIA, graus_motor);
    }

}


void acionarMotores(bool frente=true) {
    if(frente) {
        OnFwd(MOTOR_DIREITO_ESQUERDO, VELOCIDADE_MEDIA);
    }
    else {
        OnRev(MOTOR_DIREITO_ESQUERDO, VELOCIDADE_MEDIA);
    }
}


// // Gira o robô em um determinado número de graus
// void girarEmGraus(int graus) {
//     float distancia_entre_rodas = DISTANCIA_ENTRE_RODAS;  
//     float raio_roda = DIAMETRO_RODA / 2.0;  
    
//     // Distância que a roda externa precisa percorrer
//     float distancia_percorrida = (distancia_entre_rodas * PI * abs(graus)) / 360.0;
    
//     // Número de rotações que cada roda deve fazer
//     float numero_rotacoes = distancia_percorrida / (2 * PI * raio_roda);

//     if (graus > 0) {
//         acionarMotor(MOTOR_ESQUERDO, numero_rotacoes, true);  // Esquerda para frente
//         acionarMotor(MOTOR_DIREITO, numero_rotacoes, false); // Direita para trás
//     } else {
//         acionarMotor(MOTOR_ESQUERDO, numero_rotacoes, false); // Esquerda para trás
//         acionarMotor(MOTOR_DIREITO, numero_rotacoes, true);  // Direita para frente
//     }
// }


void girarEmGraus(int graus) {
    float distancia_entre_rodas = DISTANCIA_ENTRE_RODAS;
    float raio_roda = DIAMETRO_RODA / 2.0;

    // Distância que a roda externa precisa percorrer
    float distancia_percorrida = (distancia_entre_rodas * PI * abs(graus)) / 360.0;

    // Número de rotações que cada roda deve fazer
    float numero_rotacoes = distancia_percorrida / (2 * PI * raio_roda);

    // Quantos graus os motores devem girar
    int graus_motor = 360 * numero_rotacoes;

    // Se o grau é positivo, girar para a direita. Se negativo, girar para a esquerda.
    if (graus > 0) {
        // Girar para a direita
        RotateMotorEx(MOTOR_DIREITO_ESQUERDO, VELOCIDADE_MEDIA, graus_motor, -100, true, true);
    } else {
        // Girar para a esquerda
        RotateMotorEx(MOTOR_DIREITO_ESQUERDO, VELOCIDADE_MEDIA, graus_motor, 100, true, true);
    }
}


void calcularOdometria(){
    float deslocamento_motor_direito = MotorRotationCount(MOTOR_DIREITO) * PI * DIAMETRO_RODA;
    float deslocamento_motor_esquerdo = MotorRotationCount(MOTOR_ESQUERDO) * PI * DIAMETRO_RODA;
    float deslocamento_medio = (deslocamento_motor_direito + deslocamento_motor_esquerdo) / 2;
    float mudanca_angulo = (deslocamento_motor_direito - deslocamento_motor_esquerdo) / DISTANCIA_ENTRE_RODAS;

    angulo += mudanca_angulo;

    // Para projetos de robótica, é comum modificar esse ângulo para que ele esteja sempre entre -pi e +pi.
    if (angulo > PI) {
        angulo -= 2 * PI;
    } else if (angulo < -PI) {
        angulo += 2 * PI;
    }

    float delta_x = deslocamento_medio * Cos(angulo);
    float delta_y = deslocamento_medio * Sin(angulo);

    x += delta_x;
    y += delta_y;

    ClearScreen();
    TextOut(0, LCD_LINE1, "X: " + NumToStr(x));
    TextOut(0, LCD_LINE2, "Y: " + NumToStr(y));
    TextOut(0, LCD_LINE3, "Angulo: " + NumToStr(angulo));
}


void andarFrente() {
    acionarMotores();
}

void andarFrenteUmaVez() {
    acionarMotor(MOTOR_DIREITO_ESQUERDO, 1);
}

void andarTras() {
    acionarMotores(false);
}

void andarTrasUmaVez() {
    acionarMotor(MOTOR_DIREITO_ESQUERDO, 1, false);
}

void girarDireita() {
    girarEmGraus(90);
}

void girarEsquerda() {
    girarEmGraus(-90);
}

void girar180() {
    girarEmGraus(180);
}

void acionarGarra() {
    acionarMotor(MOTOR_GARRA, 1);
}

task explorar() {
    while (true) {
        andarFrente();
        calcularOdometria();
    }
}

task detectarObstaculo() {
    while (true) {
        if (SensorUS(SENSOR_ULTRASSOM) < DISTANCIA && Sensor(SENSOR_TOQUE) == 1) {
            ClearScreen();
            TextOut(0, LCD_LINE1, "Parede detectada!");
            girar180();
        }
    }
}

task detectarObjeto() {
    while (true) {
        if (SensorUS(SENSOR_ULTRASSOM) < DISTANCIA) {
            ClearScreen();
            TextOut(0, LCD_LINE1, "Objeto detectado!");
            andarFrenteUmaVez();
            acionarGarra();
        }
    }
}

task detectarCor() {
    while (true) {
        int valorLuz = Sensor(SENSOR_COR);
        if (valorLuz < 40) {
            corGlobal = PRETO;
        }
        else if(valorLuz > 50 && valorLuz < LCD_LINE1){
            corGlobal = VERMELHO;
        }
        else if (valorLuz >= 40 && valorLuz < 60) {
            corGlobal = BRANCO;
        }
        else if (valorLuz >= 60) {
            corGlobal = PRATA;
        }
    }
}


task main() {
    SetSensorLight(SENSOR_COR);
    SetSensorTouch(SENSOR_TOQUE);
    SetSensorUltrasonic(SENSOR_ULTRASSOM);

    ClearScreen();
    TextOut(0, LCD_LINE1, "Clique");
    while(Sensor(SENSOR_TOQUE) == 0) {};

    Precedes(explorar, detectarObstaculo, detectarObjeto, detectarCor);

}
