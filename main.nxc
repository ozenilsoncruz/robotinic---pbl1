// Definicao dos motores ativos
#define MOTOR_GARRA OUT_B
#define MOTOR_DIREITO OUT_A
#define MOTOR_ESQUERDO OUT_C
#define MOTOR_DIREITO_ESQUERDO OUT_AC

// Definicao dos sensores ativos
#define SENSOR_COR S3
#define SENSOR_TOQUE S1
#define SENSOR_ULTRASSOM S2

// Canal de comunica??o Bluetooth
#define MAILBOX_RECIVE 1
#define MAILBOX_SEND 2

// Potencias dos motores
#define VELOCIDADE_MAXIMA 100
#define VELOCIDADE_MEDIA 40
#define VELOCIDADE_MINIMA 30

// Distancia maxima permitida da parede
#define DISTANCIA_PAREDE 22
#define DISTANCIA_OBJETO 10

// Cores usadas
#define PRETO 1
#define PRATA 2
#define BRANCO 3
#define VERMELHO 4


// Medidas do rob?
#define DIAMETRO_RODA 7
#define DISTANCIA_ENTRE_RODAS 20


enum Estado {
    SAIR_BASE,
    MOVER_PARA_ESTOQUE,
    PROCURAR_OBJETO,
    SAIR_ESTOQUE,
    ENTRAR_ESTACAO_TRABALHO,
    ESTACAO_TRABALHO,
    SAIR_ESTACAO_TRABALHO,
    RETORNAR_BASE
};

Estado estadoAtual;

// Vari?veis globais
float x = 0;
float y = 0;
float angulo = 0;

int corDetectada = 0;
bool girar_Direita = true;
bool procurarObjeto = false;
bool objetoAdquirido = false;

float motorEsquerdoCount = 0;
float motorDireitoCount = 0;


mutex motorDireitoEsquerdoMutex;


void calcularOdometria() {
    motorDireitoCount = MotorRotationCount(MOTOR_DIREITO)/360;
    motorEsquerdoCount = MotorRotationCount(MOTOR_ESQUERDO)/360;
    float deslocamento_motor_direito = motorDireitoCount * PI * DIAMETRO_RODA;
    float deslocamento_motor_esquerdo = motorEsquerdoCount * PI * DIAMETRO_RODA;
    float deslocamento_medio = (deslocamento_motor_direito + deslocamento_motor_esquerdo) / 2;
    float mudanca_angulo = (deslocamento_motor_direito - deslocamento_motor_esquerdo) / DISTANCIA_ENTRE_RODAS;

    angulo += mudanca_angulo;

    float delta_x = deslocamento_medio * Cos(angulo);
    float delta_y = deslocamento_medio * Sin(angulo);

    x += delta_x;
    y += delta_y;
    ResetRotationCount(MOTOR_DIREITO);
    ResetRotationCount(MOTOR_ESQUERDO);
}



void acionarMotor(int motor, float num_voltas, bool frente=true) {
    //ResetRotationCount(motor);

    int graus_motor = 360 * num_voltas;  // Quantos graus o motor deve girar

    if (frente) {
        RotateMotor(motor, VELOCIDADE_MEDIA, graus_motor);
    }
    else {
        RotateMotor(motor, -VELOCIDADE_MEDIA, graus_motor);

    }
    calcularOdometria();

}


void acionarMotores(bool frente=true) {
    if(frente) {
        // TODO: testar se o robô caminha reto
        OnFwd(MOTOR_DIREITO, VELOCIDADE_MEDIA - 2);
        OnFwd(MOTOR_ESQUERDO, VELOCIDADE_MEDIA);

    }
    else {
        OnRev(MOTOR_DIREITO_ESQUERDO, VELOCIDADE_MEDIA);
    }
}



void girarEmGraus(int graus) {
    float distancia_entre_rodas = DISTANCIA_ENTRE_RODAS;
    float raio_roda = DIAMETRO_RODA / 2.0;

    // Dist?ncia que a roda externa precisa percorrer
    float distancia_percorrida = (distancia_entre_rodas * PI * abs(graus)) / 360.0;

    // N?mero de rota??es que cada roda deve fazer
    float numero_rotacoes = distancia_percorrida / (2 * PI * raio_roda);

    // Quantos graus os motores devem girar
    int graus_motor = 360 * numero_rotacoes;

    // Se o grau ? positivo, girar para a direita. Se negativo, girar para a esquerda.
    if (graus > 0) {
        // Girar para a direita
        RotateMotorEx(MOTOR_DIREITO_ESQUERDO, VELOCIDADE_MEDIA, graus_motor, -100, true, true);
    } else {
        // Girar para a esquerda
        RotateMotorEx(MOTOR_DIREITO_ESQUERDO, VELOCIDADE_MEDIA, graus_motor, 100, true, true);
    }
    calcularOdometria();
}


void andarFrente() {
    acionarMotores();
}

void andarFrenteUmaVez() {
    acionarMotor(MOTOR_DIREITO_ESQUERDO, 1);
}

void andarFrenteNumeroVezes(int vezes) {
    acionarMotor(MOTOR_DIREITO_ESQUERDO, vezes);
}

void andarTras() {
    acionarMotores(false);
}

void andarTrasUmaVez() {
    acionarMotor(MOTOR_DIREITO_ESQUERDO, 0.5, false);
}

void andarTrasNumeroVezes(int vezes) {
    acionarMotor(MOTOR_DIREITO_ESQUERDO, vezes, false);
}

void frear() {
    Off(MOTOR_DIREITO_ESQUERDO);
    calcularOdometria();
}

void girarDireita() {
    girarEmGraus(-90);
}

void girarEsquerda() {
    girarEmGraus(90);
}

void girar180() {
    girarEmGraus(180);
}

void acionarGarra() {
    acionarMotor(MOTOR_GARRA, 0.1, false);
    Off(MOTOR_GARRA);
}

void liberarGarra() {
    acionarMotor(MOTOR_GARRA, 0.1);
    Off(MOTOR_GARRA);
    objetoAdquirido = false;
}


void pegarObjeto() {
    int valor = SensorUS(SENSOR_ULTRASSOM);
        if (SensorUS(SENSOR_ULTRASSOM) < DISTANCIA_OBJETO && Sensor(SENSOR_TOQUE) == 0) {
            frear();
            andarFrenteNumeroVezes(0.8);
            acionarGarra();
            objetoAdquirido = true;
        }
}

string lerCor(int cor) {
    if (cor == 1) {
        return "Preto";
    }
    else if (cor == 2) {
        return "Prata";
    }
    else if (cor == 3) {
        return "Branco";
    }
    else return "Nao identificado";
}

task mostrarInformacoes() {
    while(true) {
        ClearScreen();
        int distancia = SensorUS(SENSOR_ULTRASSOM);
        int valorLuz = Sensor(SENSOR_COR);
        TextOut(0, LCD_LINE1, "Distancia:" + NumToStr(distancia));
        TextOut(0, LCD_LINE2, "Cor:" + lerCor(corDetectada) + " V:" + NumToStr(valorLuz));
        TextOut(0, LCD_LINE3, "Estado:" + NumToStr(estadoAtual));
        TextOut(0, LCD_LINE4, "D" + NumToStr(motorDireitoCount) + " E:" + NumToStr(motorEsquerdoCount));
        TextOut(0, LCD_LINE5, "X:" + NumToStr(x));
        TextOut(0, LCD_LINE6, "Y:" + NumToStr(y));
        TextOut(0, LCD_LINE7, "Angulo: " + NumToStr(angulo));
        Wait(100);
    }
}


task seguirLinhaPreta() {
    bool ajustarParaDireita = true;
    while (true) {

        if (corDetectada == PRETO) {
            andarFrente();
        }
        // Se o sensor detecta outra cor (linha perdida)
        else {
            frear();
            if (ajustarParaDireita) {
                // Curva ligeira para a direita
                girarEmGraus(30);
            } else {
                // Curva ligeira para a esquerda
                girarEmGraus(-30);
            }
            ajustarParaDireita = !ajustarParaDireita;
        }
        Wait(50);
    }
}

task detectarParede() {
    while (true) {
        Acquire(motorDireitoEsquerdoMutex);
        if (Sensor(SENSOR_TOQUE) == 1) {
            frear();
            andarTrasUmaVez();
            girarDireita();
        }
        Release(motorDireitoEsquerdoMutex);
    }
}


task explorar() {
    while (true) {
        Acquire(motorDireitoEsquerdoMutex);
        if(procurarObjeto && !objetoAdquirido) {
            andarFrenteUmaVez();
            pegarObjeto();
            girarEmGraus(45);
            pegarObjeto();
            girarEmGraus(-45);
        }
        Release(motorDireitoEsquerdoMutex);
    }
}

task detectarObjeto() {
    while (true) {
        if(procurarObjeto) {
            Acquire(motorDireitoEsquerdoMutex);
            int valor = SensorUS(SENSOR_ULTRASSOM);
            if (SensorUS(SENSOR_ULTRASSOM) < DISTANCIA_OBJETO && Sensor(SENSOR_TOQUE) == 0) {
                frear();
                andarFrenteNumeroVezes(0.8);
                acionarGarra();
                objetoAdquirido = true;
            }
            Release(motorDireitoEsquerdoMutex);
        }
    }
}


task detectarCor() {
    // TODO: Implementar lógica para detectar a cor vermelha
    // SetSensorLight(SENSOR_COR, false);
    while (true) {
        int valorLuz = Sensor(SENSOR_COR);
        if (valorLuz < 40) {
            corDetectada = PRETO;
        }
        else if (valorLuz >= 40 && valorLuz < 60) {
            corDetectada = BRANCO;
        }
        else if (valorLuz >= 65) {
            corDetectada = PRATA;
        }
        Wait(100);
    }
}


// Fun??o principal de atualiza??o de estado
task atualizarEstado() {
    estadoAtual = MOVER_PARA_ESTOQUE;
    while (true) {
        Acquire(motorDireitoEsquerdoMutex);
        switch (estadoAtual) {
            // case SAIR_BASE: //Estado OK!
            //     if (corDetectada == PRATA) {
            //         frear();
            //         andarFrente();
            //         Wait(1000);
            //         estadoAtual = MOVER_PARA_ESTOQUE;
            //     }
            //     else if(corDetectada == BRANCO) {
            //         andarFrente();
            //     }
            //     else if (corDetectada == PRETO) {
            //         frear();
            //         andarTrasUmaVez();
            //         girarDireita();
            //         andarFrenteUmaVez();
            //         girarEsquerda();
            //     }
            //     break;
            case MOVER_PARA_ESTOQUE:
                if (corDetectada == PRATA) {
                    frear();
                    andarFrenteUmaVez();
                    estadoAtual = PROCURAR_OBJETO;
                }
                else if(corDetectada == BRANCO) {
                    andarFrente();
                }
                else if (corDetectada == PRETO) {
                    frear();
                    andarTrasUmaVez();
                    girarDireita();
                    andarFrenteUmaVez();
                    girarEsquerda();
                }
                break;
            case PROCURAR_OBJETO:
                procurarObjeto = true;
                if (objetoAdquirido) {
                    procurarObjeto = false;
                    andarFrente()
                    // estadoAtual = SAIR_ESTOQUE;
                    break;
                }
                else if(corDetectada == PRATA || corDetectada == PRETO) {
                    frear();
                    andarTrasUmaVez();
                    girar180();
                }
                else if(corDetectada == BRANCO) {
                    andarFrente();
                }
                break;
            // case SAIR_ESTOQUE:
            //     if (corDetectada == PRATA) {
            //         frear();
            //         andarFrenteUmaVez();
            //         girarEsquerda();
            //         estadoAtual = ENTRAR_ESTACAO_TRABALHO,;
            //         andarFrente();
            //     }
            //     else if(corDetectada == BRANCO) {
            //         andarFrente();
            //     }
            //     else if (corDetectada == PRETO) {
            //         frear();
            //         andarTrasUmaVez();
            //         girarDireita();
            //         andarFrenteUmaVez();
            //         girarEsquerda();
            //     }
            //     break;

        //     case ENTRAR_ESTACAO_TRABALHO:
        //         if (corDetectada == PRATA) {
        //             andarFrente();
        //             estadoAtual = ESTACAO_TRABALHO;
        //             break;
        //         }
        //         if(corDetectada == BRANCO) {
        //             andarFrente();
        //         }
        //         else if (corDetectada == PRETO) {
        //             frear();
        //             andarTrasUmaVez();
        //             girarDireita();
        //             andarFrenteUmaVez();
        //             girarEsquerda();
        //             andarFrenteUmaVez();
        //             girarEsquerda();
        //         }
        //         break;
            // case: ESTACAO_TRABALHO:
            //     SetSensorLight(SENSOR_COR, false);
            //     if (corDetectada == VERMELHO) {
            //         frear();
            //         girar180();
            //         andarFrente();
            //         estadoAtual = SAIR_ESTACAO_TRABALHO;
            //         SetSensorLight(SENSOR_COR, true);
            //         break;
            //     }
            //     if(corDetectada == BRANCO) {
            //         andarFrente();
            //     }
            //     else if (corDetectada == PRETO) {
            //         frear();
            //         andarTrasUmaVez();
            //         liberarGarra();
            //         girar180();
            //         andarFrente();
            //         estadoAtual = SAIR_ESTACAO_TRABALHO;
            //         SetSensorLight(SENSOR_COR, true);
            //     }
            //     break;
        //     case SAIR_ESTACAO_TRABALHO:
        //         if (corDetectada == PRATA) {
        //             if(objetoAdquirido) {
        //                 frear();
        //                 andarFrenteUmaVez();
        //                 girarEsquerda();
        //                 estadoAtual = RETORNAR_BASE;
        //                 andarFrente();
        //             }
        //             else {
        //                 andarFrente();
        //                 estadoAtual = ENTRAR_ESTACAO_TRABALHO;
        //             }
        //         }
        //         else if(corDetectada == BRANCO) {
        //             andarFrente();
        //         }
        //         else if (corDetectada == PRETO) {
        //             frear();
        //             andarTrasUmaVez();
        //             girarDireita();
        //         }
        //         break;
        // }
        Release(motorDireitoEsquerdoMutex);
        Wait(100);
    }
}

task main() {
    SetSensorLight(SENSOR_COR);
    SetSensorTouch(SENSOR_TOQUE);
    SetSensorUltrasonic(SENSOR_ULTRASSOM);

    // SendMessage(MAILBOX_SEND, "Iniciando rob?");

    // string msg;
    // while(true) {
    //     ReceiveMessage(MAILBOX_RECIVE, true, msg);
    //     if (msg == "iniciar") {
    //         ClearScreen();
    //         TextOut(0, LCD_LINE1, msg);
    //         break;
    //     }
    // }

   // liberarGarra();
    Precedes(atualizarEstado, detectarCor, detectarParede, explorar, mostrarInformacoes);



}

















